# Spring PetClinic Customers Service 深入解析
## 從實務角度理解微服務設計

在開始之前，我想先說：**如果你能理解 Customers Service 的設計，其他微服務基本上就是照著這個模式依樣畫葫蘆**。這也是為什麼我選擇從這個服務開始講起。

## 為什麼要有 Customers Service？

做過一陣子開發的朋友應該都知道，在真實的專案中，需求永遠在變。今天產品經理說要加個欄位，明天老闆說要改個邏輯，後天客戶又說這個功能不對...（沒錯，我們都是這樣活過來的）

那如果你把「客戶管理」、「寵物管理」、「預約管理」全部塞在同一個服務裡，會發生什麼事？

**改客戶欄位 → 整包重新打包 → 預約功能也要重新部署 → 結果出包了大家一起陪葬**

所以，**微服務的第一個思維就是：拆開來，各自負責，互不干擾**。

Customers Service 就是專門負責「管理飼主與寵物資料」的服務，別的事情它不管，專心做好這件事就好。

---

## 從資料結構開始理解

寫程式這麼多年，我學到一件事：**先搞清楚資料長什麼樣子，程式邏輯自然就清楚了**。

### Owner（飼主）實體

```java
@Entity
@Table(name = "owners")
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    @Column(name = "first_name")
    private String firstName;
    
    @Column(name = "last_name")
    private String lastName;
    
    private String address;
    private String city;
    
    @Column(name = "telephone")
    @Pattern(regexp = "\\d{10}", message = "電話必須是10位數字")
    private String telephone;
    
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private Set<Pet> pets = new HashSet<>();
}
```

這段程式碼其實就在描述一件很簡單的事：
- **@Entity**：告訴 JPA「這是一張資料表」
- **@Table**：對應到資料庫的 `owners` 表
- **@OneToMany**：一個飼主可以養多隻寵物（這不是廢話嗎）

但重點是 `@Pattern` 這個註解。為什麼要加？因為你不加，使用者就會輸入一堆奇怪的東西進來：
- 有人輸 `0912-345-678`（有破折號）
- 有人輸 `+886912345678`（有國碼）
- 有人直接貼家裡電話 `(02)2345-6789`

**資料驗證永遠要在進資料庫之前就擋掉**，不然出問題再來撈資料修正，那才叫真正的痛苦。

### Pet（寵物）實體

```java
@Entity
@Table(name = "pets")
public class Pet {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    
    @Column(name = "birth_date")
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private LocalDate birthDate;
    
    @ManyToOne
    @JoinColumn(name = "type_id")
    private PetType type;
    
    @ManyToOne
    @JoinColumn(name = "owner_id")
    private Owner owner;
}
```

這裡有個細節：**為什麼寵物品種（PetType）要獨立出來當一張表？**

答案很簡單：**因為下拉選單的選項需要管理**。如果你直接用 String 存「柴犬」、「黃金獵犬」，那使用者可能會輸入：
- `柴犬`、`Shiba`、`shiba inu`、`柴柴`...

結果你的報表要統計「柴犬有幾隻」，光是處理這些不一致的資料就夠你喝一壺的。

---

## Repository 層：與資料庫對話

```java
public interface OwnerRepository extends JpaRepository<Owner, Integer> {
    
    /**
     * 根據姓氏模糊查詢
     */
    @Query("SELECT DISTINCT owner FROM Owner owner " +
           "LEFT JOIN FETCH owner.pets " +
           "WHERE owner.lastName LIKE :lastName%")
    List<Owner> findByLastName(@Param("lastName") String lastName);
    
    /**
     * 根據 ID 查詢，並一次把寵物資料也抓出來
     */
    @Query("SELECT owner FROM Owner owner " +
           "LEFT JOIN FETCH owner.pets " +
           "WHERE owner.id = :id")
    Owner findById(@Param("id") Integer id);
}
```

這裡有個很重要的觀念：**N+1 查詢問題**。

假設你這樣寫：
```java
Owner owner = ownerRepository.findById(1);
Set<Pet> pets = owner.getPets();  // 觸發額外的 SQL 查詢
```

會發生什麼事？
1. 第一次查詢：抓 Owner 資料（1 次 SQL）
2. 第二次查詢：因為用到 `getPets()`，JPA 才去抓寵物資料（又 1 次 SQL）

如果你要顯示 100 個飼主的列表，每個飼主都要查一次寵物，那就是 **1 + 100 = 101 次 SQL 查詢**。

**這就是為什麼要用 `LEFT JOIN FETCH`**，一次把關聯的資料全部撈出來，只需要 1 次 SQL。

真實專案中，效能問題常常就是這種小地方累積出來的。

---

## Service 層：業務邏輯的守門員

```java
@Service
public class OwnerService {
    
    private final OwnerRepository ownerRepository;
    
    public Owner save(Owner owner) {
        // 業務規則 1：電話號碼不能重複
        if (ownerRepository.existsByTelephone(owner.getTelephone())) {
            throw new DuplicateResourceException("此電話已被註冊");
        }
        
        // 業務規則 2：同一飼主不能有重複的寵物名字
        Set<String> petNames = owner.getPets().stream()
            .map(Pet::getName)
            .collect(Collectors.toSet());
        
        if (petNames.size() != owner.getPets().size()) {
            throw new BusinessRuleException("寵物名字不能重複");
        }
        
        return ownerRepository.save(owner);
    }
    
    public void addPet(Integer ownerId, Pet pet) {
        Owner owner = ownerRepository.findById(ownerId)
            .orElseThrow(() -> new ResourceNotFoundException("找不到此飼主"));
        
        // 業務規則 3：寵物生日不能是未來
        if (pet.getBirthDate().isAfter(LocalDate.now())) {
            throw new BusinessRuleException("寵物生日不能是未來日期");
        }
        
        // 業務規則 4：每個飼主最多養 10 隻寵物
        if (owner.getPets().size() >= 10) {
            throw new BusinessRuleException("每個飼主最多只能登記 10 隻寵物");
        }
        
        owner.addPet(pet);
        ownerRepository.save(owner);
    }
}
```

**Service 層就是業務邏輯的家**。為什麼不寫在 Controller？因為：
1. **Controller 明天可能從 REST API 改成 GraphQL**，業務邏輯不該跟著改
2. **Service 層可以被測試**，不需要真的啟動 Web Server
3. **業務邏輯集中管理**，要改規則只要改這裡

我見過太多專案把邏輯寫在 Controller，結果後來要改需求，每個 Endpoint 都要改一遍，改到懷疑人生。

---

## Controller 層：對外的窗口

```java
@RestController
@RequestMapping("/api/owners")
public class OwnerController {
    
    private final OwnerService ownerService;
    
    /**
     * 查詢飼主列表
     */
    @GetMapping
    public ResponseEntity<List<OwnerDTO>> searchOwners(
            @RequestParam(required = false) String lastName) {
        
        List<Owner> owners = lastName != null 
            ? ownerService.findByLastName(lastName)
            : ownerService.findAll();
        
        List<OwnerDTO> dtos = owners.stream()
            .map(OwnerMapper::toDTO)
            .collect(Collectors.toList());
        
        return ResponseEntity.ok(dtos);
    }
    
    /**
     * 新增飼主
     */
    @PostMapping
    public ResponseEntity<OwnerDTO> createOwner(@Valid @RequestBody OwnerDTO dto) {
        Owner owner = OwnerMapper.toEntity(dto);
        Owner saved = ownerService.save(owner);
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(OwnerMapper.toDTO(saved));
    }
    
    /**
     * 為飼主新增寵物
     */
    @PostMapping("/{ownerId}/pets")
    public ResponseEntity<PetDTO> addPet(
            @PathVariable Integer ownerId,
            @Valid @RequestBody PetDTO dto) {
        
        Pet pet = PetMapper.toEntity(dto);
        ownerService.addPet(ownerId, pet);
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(PetMapper.toDTO(pet));
    }
    
    /**
     * 全域例外處理
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse(ex.getMessage()));
    }
}
```

### 為什麼要用 DTO？

你可能會問：**為什麼不直接把 Entity 回傳給前端？**

理由很簡單：
1. **Entity 裡有一堆你不想給前端看的東西**（例如密碼欄位、內部 ID）
2. **前端需要的資料格式，跟資料庫結構不一定一樣**
3. **避免 Jackson 序列化時的循環參考問題**（Owner 有 Pet，Pet 又有 Owner，序列化會爆掉）

DTO（Data Transfer Object）就是**專門用來傳輸的資料格式**，乾乾淨淨，要什麼欄位就放什麼欄位。

---

## 單元測試：工程師的安全帶

我常跟團隊說：**沒寫測試的程式碼，就像開車不繫安全帶**。平常沒事，出事的時候就知道痛了。

### Repository 測試

```java
@DataJpaTest  // 只啟動 JPA 相關的元件，測試快速
@AutoConfigureTestDatabase(replace = NONE)  // 使用真實的測試資料庫
class OwnerRepositoryTest {
    
    @Autowired
    private OwnerRepository repository;
    
    @Test
    @DisplayName("測試：根據姓氏模糊查詢")
    void testFindByLastName() {
        // Given：準備測試資料
        Owner owner1 = new Owner("小明", "王", "台北市");
        Owner owner2 = new Owner("小華", "王", "新北市");
        Owner owner3 = new Owner("大偉", "李", "桃園市");
        
        repository.saveAll(Arrays.asList(owner1, owner2, owner3));
        
        // When：執行查詢
        List<Owner> result = repository.findByLastName("王");
        
        // Then：驗證結果
        assertThat(result).hasSize(2);
        assertThat(result).extracting("firstName")
            .containsExactlyInAnyOrder("小明", "小華");
    }
    
    @Test
    @DisplayName("測試：查詢不存在的姓氏應回傳空列表")
    void testFindByLastName_NotFound() {
        List<Owner> result = repository.findByLastName("不存在的姓");
        assertThat(result).isEmpty();
    }
}
```

### Service 測試

```java
@ExtendWith(MockitoExtension.class)
class OwnerServiceTest {
    
    @Mock
    private OwnerRepository ownerRepository;
    
    @InjectMocks
    private OwnerService ownerService;
    
    @Test
    @DisplayName("測試：新增寵物時檢查名字重複")
    void testAddPet_DuplicateName() {
        // Given：飼主已經有一隻叫「小白」的狗
        Owner owner = new Owner("小明", "王");
        Pet existingPet = new Pet("小白", LocalDate.of(2020, 5, 10));
        owner.addPet(existingPet);
        
        when(ownerRepository.findById(1)).thenReturn(Optional.of(owner));
        
        // When & Then：嘗試新增另一隻叫「小白」的貓，應該要報錯
        Pet duplicatePet = new Pet("小白", LocalDate.of(2021, 3, 15));
        
        assertThatThrownBy(() -> ownerService.addPet(1, duplicatePet))
            .isInstanceOf(BusinessRuleException.class)
            .hasMessageContaining("寵物名字不能重複");
        
        // 驗證：不應該呼叫 save
        verify(ownerRepository, never()).save(any());
    }
    
    @Test
    @DisplayName("測試：寵物生日不能是未來")
    void testAddPet_FutureBirthDate() {
        Owner owner = new Owner("小明", "王");
        when(ownerRepository.findById(1)).thenReturn(Optional.of(owner));
        
        Pet futurePet = new Pet("時光機", LocalDate.now().plusDays(1));
        
        assertThatThrownBy(() -> ownerService.addPet(1, futurePet))
            .isInstanceOf(BusinessRuleException.class)
            .hasMessageContaining("寵物生日不能是未來日期");
    }
}
```

### Controller 測試（Integration Test）

```java
@SpringBootTest
@AutoConfigureMockMvc
class OwnerControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    @DisplayName("測試：新增飼主的完整流程")
    void testCreateOwner() throws Exception {
        OwnerDTO dto = new OwnerDTO();
        dto.setFirstName("小美");
        dto.setLastName("陳");
        dto.setAddress("台中市西屯區");
        dto.setTelephone("0912345678");
        
        mockMvc.perform(post("/api/owners")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(dto)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").exists())
            .andExpect(jsonPath("$.firstName").value("小美"))
            .andExpect(jsonPath("$.lastName").value("陳"));
    }
    
    @Test
    @DisplayName("測試：電話格式錯誤應回傳 400")
    void testCreateOwner_InvalidTelephone() throws Exception {
        OwnerDTO dto = new OwnerDTO();
        dto.setFirstName("小美");
        dto.setLastName("陳");
        dto.setTelephone("12345");  // 錯誤格式
        
        mockMvc.perform(post("/api/owners")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(dto)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.errors").exists());
    }
}
```

---

## 實務經驗談

### 1. 分頁是必須的

如果你的系統會有超過 100 筆資料，**請一開始就做分頁**。不要等到資料庫有 10 萬筆資料才來改，那時候改起來痛苦萬分。

```java
@GetMapping
public Page<OwnerDTO> findAll(Pageable pageable) {
    return ownerService.findAll(pageable)
        .map(OwnerMapper::toDTO);
}

// 呼叫範例：GET /api/owners?page=0&size=20&sort=lastName,asc
```

### 2. 日誌要寫，但別寫太多

```java
@Slf4j
@Service
public class OwnerService {
    
    public Owner save(Owner owner) {
        log.info("嘗試儲存飼主：{} {}", owner.getFirstName(), owner.getLastName());
        
        try {
            Owner saved = ownerRepository.save(owner);
            log.info("飼主儲存成功，ID：{}", saved.getId());
            return saved;
        } catch (Exception e) {
            log.error("儲存飼主失敗：{}", owner, e);
            throw e;
        }
    }
}
```

**重點在於：記錄關鍵操作、記錄錯誤、別記錄敏感資訊（密碼、身分證字號）**。

### 3. 快取可以晚點加

很多人一開始就想加 Redis 快取，但其實**大部分應用根本不需要**。除非你的 QPS 真的很高，或是查詢真的很慢，不然別過早優化。

真要加，也很簡單：
```java
@Cacheable(value = "owners", key = "#id")
public Owner findById(Integer id) {
    return ownerRepository.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("找不到此飼主"));
}
```

---

## 小結

Customers Service 的設計，其實就是**標準的三層式架構**：
- **Repository 層**：負責資料庫存取
- **Service 層**：負責業務邏輯
- **Controller 層**：負責 HTTP 請求處理

這個架構簡單、清楚、易維護，**適合 80% 的應用場景**。

剩下的 20%？那就是你要考慮 CQRS、Event Sourcing、Hexagonal Architecture 這些進階模式的時候了。但說真的，**大部分專案根本用不到這麼複雜的東西**。

記住：**能用簡單的方式解決問題，就不要用複雜的方式**。寫程式不是比誰的架構設計得最精妙，而是比誰能讓團隊最快完成需求、最好維護、最少出包。

這才是工程師該有的務實態度。

---

## 附錄：完整的專案結構

```
spring-petclinic-customers-service/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── org/springframework/samples/petclinic/customers/
│   │   │       ├── model/              # 實體類別
│   │   │       │   ├── Owner.java
│   │   │       │   ├── Pet.java
│   │   │       │   └── PetType.java
│   │   │       ├── repository/         # 資料庫存取
│   │   │       │   ├── OwnerRepository.java
│   │   │       │   └── PetRepository.java
│   │   │       ├── service/            # 業務邏輯
│   │   │       │   └── OwnerService.java
│   │   │       ├── web/                # REST API
│   │   │       │   ├── OwnerController.java
│   │   │       │   ├── dto/
│   │   │       │   │   ├── OwnerDTO.java
│   │   │       │   │   └── PetDTO.java
│   │   │       │   └── mapper/
│   │   │       │       └── OwnerMapper.java
│   │   │       └── CustomersServiceApplication.java
│   │   └── resources/
│   │       ├── application.yml
│   │       └── bootstrap.yml           # Config Server 連線設定
│   └── test/
│       └── java/
│           └── org/springframework/samples/petclinic/customers/
│               ├── repository/
│               │   └── OwnerRepositoryTest.java
│               ├── service/
│               │   └── OwnerServiceTest.java
│               └── web/
│                   └── OwnerControllerIntegrationTest.java
└── pom.xml
```

這就是一個完整、實用、經得起考驗的微服務架構。
